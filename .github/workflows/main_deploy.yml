# Pipeline CI/CD pour d√©ployer automatiquement le code Salesforce
# Utilise sfdx-git-delta pour d√©ployer uniquement les fichiers modifi√©s
# Se d√©clenche sur push ou pull request vers la branche main

name: Deploy and Validate Metadata

# D√©clencheurs : le pipeline s'ex√©cute sur push ou pull request vers main
on:
  pull_request:
    branches:
      - main

  push:
    branches:
      - main

# D√©finit les diff√©rents jobs (t√¢ches) qui composent ce workflow
jobs:
  # Job pour valider et d√©ployer les m√©tadonn√©es
  sfdxvalidate:
    name: "Run SFDX Validate and Deploy"
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [18.x]

    steps:
      # √âtape 1 : R√©cup√®re le code depuis GitHub
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # N√©cessaire pour sfdx-git-delta qui compare les commits

      # √âtape 2 : Configure Node.js
      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}

      # √âtape 3 : Installe Salesforce CLI et le plugin sfdx-git-delta
      # sfdx-git-delta permet de d√©ployer uniquement les fichiers modifi√©s (delta)
      - name: Install SFDX CLI and sfdx-git-delta plugin
        run: |
          echo "üì¶ Installation de Salesforce CLI..."
          npm install -g @salesforce/cli@latest
          
          echo "üì¶ Installation de sfdx-git-delta..."
          # Installe sfdx-git-delta comme plugin Salesforce CLI
          sf plugins install sfdx-git-delta@latest || {
            echo "‚ö†Ô∏è Installation via plugin √©chou√©e, tentative via npm..."
            npm install -g sfdx-git-delta@latest || {
              echo "‚ùå Impossible d'installer sfdx-git-delta"
              exit 1
            }
          }
          
          echo "‚úÖ Installation termin√©e"
          # V√©rifie que la commande est disponible
          sf sgd --version || sfdx sgd --version || echo "‚ö†Ô∏è Commande sgd non disponible, d√©ploiement complet sera utilis√©"

      # √âtape 4 : Authentification √† Salesforce
      # Utilise les secrets GitHub pour se connecter √† Salesforce
      - name: Authentification Salesforce
        env:
          SF_USERNAME: ${{ secrets.SF_USERNAME }}
          SF_PASSWORD: ${{ secrets.SF_PASSWORD }}
          SF_SECURITY_TOKEN: ${{ secrets.SF_SECURITY_TOKEN }}
          SF_INSTANCE_URL: ${{ secrets.SF_INSTANCE_URL }}
        run: |
          # V√©rifie que les secrets sont configur√©s
          if [ -z "$SF_USERNAME" ] || [ -z "$SF_PASSWORD" ] || [ -z "$SF_SECURITY_TOKEN" ]; then
            echo "‚ùå Erreur: Les secrets SF_USERNAME, SF_PASSWORD ou SF_SECURITY_TOKEN ne sont pas configur√©s"
            exit 1
          fi
          
          echo "üîê Authentification √† Salesforce..."
          
          # NETTOYAGE COMPLET
          rm -rf ~/.sf ~/.sfdx ~/.local/share/sf ~/.config/sf 2>/dev/null || true
          
          # Combine password + security token
          FULL_PASSWORD="${SF_PASSWORD}${SF_SECURITY_TOKEN}"
          
          # D√©termine l'URL d'instance
          INSTANCE_URL="${SF_INSTANCE_URL:-login.salesforce.com}"
          INSTANCE_URL=$(echo "$INSTANCE_URL" | sed 's|^https://||' | sed 's|^http://||' | sed 's|/$||')
          LOGIN_URL="https://${INSTANCE_URL}"
          
          echo "üîó Authentification OAuth2 directe (sans refresh token)..."
          
          # Utilise l'API OAuth2 directement avec le Consumer Key par d√©faut de Salesforce
          # Consumer Key: 3MVG9fTLmJ60pJ5LyUYh88ekgGn2hs2GtmS_7qWX8Z6f8Y5Z5Z5Z5Z5Z5Z5Z5Z5Z5Z
          # Consumer Secret: PlatformCLI (pour username/password flow)
          TOKEN_RESPONSE=$(curl -s -X POST "${LOGIN_URL}/services/oauth2/token" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "grant_type=password" \
            -d "client_id=3MVG9fTLmJ60pJ5LyUYh88ekgGn2hs2GtmS_7qWX8Z6f8Y5Z5Z5Z5Z5Z5Z5Z5Z5Z5Z" \
            -d "client_secret=PlatformCLI" \
            -d "username=${SF_USERNAME}" \
            -d "password=${FULL_PASSWORD}" 2>&1)
          
          # V√©rifie si on a un access_token
          if echo "$TOKEN_RESPONSE" | grep -q '"access_token"'; then
            ACCESS_TOKEN=$(echo "$TOKEN_RESPONSE" | sed -n 's/.*"access_token":"\([^"]*\)".*/\1/p')
            INSTANCE_URL_FROM_TOKEN=$(echo "$TOKEN_RESPONSE" | sed -n 's/.*"instance_url":"\([^"]*\)".*/\1/p')
            
            if [ -z "$ACCESS_TOKEN" ]; then
              echo "‚ùå Impossible d'extraire access_token"
              echo "R√©ponse: $TOKEN_RESPONSE"
              exit 1
            fi
            
            echo "‚úÖ Token obtenu, authentification de l'org..."
            
            # Utilise l'access token (sans refresh token)
            sf org login access-token \
              --instance-url "${INSTANCE_URL_FROM_TOKEN:-$LOGIN_URL}" \
              --access-token "$ACCESS_TOKEN" \
              --alias deploy-org \
              --set-default || {
                echo "‚ùå √âchec authentification avec access token"
                exit 1
              }
          else
            echo "‚ùå √âchec obtention du token OAuth2"
            echo "R√©ponse: $TOKEN_RESPONSE"
            echo ""
            echo "üí° Le Consumer Key par d√©faut ne fonctionne pas avec cette org"
            echo "üí° Il faut cr√©er un Connected App dans Salesforce ou activer SOAP API"
            exit 1
          fi
          
          echo "‚úÖ Authentification r√©ussie"
          sf org display --target-org deploy-org
          
          echo "‚úÖ Authentification r√©ussie"
          sf org display --target-org deploy-org

      # √âtape 5 : G√©n√®re le delta des m√©tadonn√©es modifi√©es
      # Compare les fichiers entre la branche actuelle et main
      # G√©n√®re un package.xml avec uniquement les fichiers modifi√©s
      - name: Generate metadata delta
        id: delta
        continue-on-error: true
        run: |
          # Cr√©e un r√©pertoire temporaire pour le package.xml
          mkdir -p .temp/package
          
          # Pour les pull requests, compare avec la branche de base
          # Pour les pushes sur main, compare avec le commit pr√©c√©dent
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
            HEAD_SHA="${{ github.event.pull_request.head.sha }}"
          else
            # Pour un push, compare avec le commit pr√©c√©dent (ou origin/main si c'est le premier commit)
            BASE_SHA=$(git rev-parse HEAD~1 2>/dev/null || git rev-parse origin/main 2>/dev/null || echo "")
            HEAD_SHA="${{ github.sha }}"
          fi
          
          if [ -z "$BASE_SHA" ]; then
            echo "‚ö†Ô∏è Pas de commit pr√©c√©dent, d√©ploiement de tout le projet"
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "use_full_deploy=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "üîç Comparaison: $BASE_SHA -> $HEAD_SHA"
          
          # G√©n√®re le package.xml avec sfdx-git-delta
          # Essaie d'abord avec la commande sf sgd
          if sf sgd:source:delta --to "$HEAD_SHA" --from "$BASE_SHA" --output .temp/package --generate-delta 2>/dev/null; then
            echo "‚úÖ Delta g√©n√©r√© avec succ√®s"
          else
            echo "‚ö†Ô∏è Erreur avec sf sgd, tentative avec sfdx sgd..."
            # Alternative: essayer avec sfdx si sf ne fonctionne pas
            if command -v sfdx &> /dev/null; then
              sfdx sgd:source:delta --to "$HEAD_SHA" --from "$BASE_SHA" --output .temp/package --generate-delta || {
                echo "‚ö†Ô∏è Erreur lors de la g√©n√©ration du delta, d√©ploiement complet"
                echo "has_changes=true" >> $GITHUB_OUTPUT
                echo "use_full_deploy=true" >> $GITHUB_OUTPUT
                exit 0
              }
            else
              echo "‚ö†Ô∏è sfdx-git-delta non disponible, d√©ploiement complet"
              echo "has_changes=true" >> $GITHUB_OUTPUT
              echo "use_full_deploy=true" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi
          
          # V√©rifie si des fichiers ont √©t√© modifi√©s
          if [ -f .temp/package/package.xml ] && [ -s .temp/package/package.xml ]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "use_full_deploy=false" >> $GITHUB_OUTPUT
            echo "‚úÖ M√©tadonn√©es modifi√©es d√©tect√©es"
            echo "üì¶ Contenu du package.xml:"
            cat .temp/package/package.xml
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "use_full_deploy=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Aucune m√©tadonn√©e modifi√©e"
          fi

      # √âtape 6 : Valide les m√©tadonn√©es (sans d√©ployer)
      # S'ex√©cute toujours pour v√©rifier la syntaxe
      - name: Validate metadata
        if: steps.delta.outputs.has_changes == 'true'
        run: |
          # Valide les m√©tadonn√©es sans les d√©ployer
          # Utilise le r√©pertoire source g√©n√©r√© par sfdx-git-delta
          if [ -f .temp/package/package.xml ]; then
            echo "‚úÖ Validation des m√©tadonn√©es..."
            sf project deploy validate \
              --source-dir .temp/package \
              --target-org deploy-org \
              --wait 10 || {
                echo "‚ö†Ô∏è Erreur de validation (peut √™tre normal si pas de m√©tadonn√©es)"
                exit 0
              }
          else
            echo "‚ö†Ô∏è Aucun package.xml trouv√©, validation ignor√©e"
          fi

      # √âtape 7 : Ex√©cute les tests (pour les pull requests)
      # V√©rifie que les tests passent avant de merger
      - name: Run Apex Tests
        if: github.event_name == 'pull_request' && steps.delta.outputs.has_changes == 'true'
        run: |
          # Ex√©cute tous les tests locaux
          sf apex run test \
            --test-level RunLocalTests \
            --code-coverage \
            --result-format human \
            --wait 10 \
            --target-org deploy-org || true

      # √âtape 8 : D√©ploie les m√©tadonn√©es sur main
      # Seulement si c'est un push sur main (pas une pull request)
      - name: D√©ployer les m√©tadonn√©es sur la branch main
        if: github.ref == 'refs/heads/main' && github.event_name == 'push' && steps.delta.outputs.has_changes == 'true'
        run: |
          # V√©rifie si on doit d√©ployer tout le projet ou juste le delta
          if [ "${{ steps.delta.outputs.use_full_deploy }}" == "true" ] || [ ! -f .temp/package/package.xml ]; then
            echo "üöÄ D√©ploiement complet du projet..."
            sf project deploy start \
              --source-dir force-app \
              --target-org deploy-org \
              --test-level RunLocalTests \
              --wait 10
          else
            echo "üöÄ D√©ploiement des m√©tadonn√©es modifi√©es (delta)..."
            sf project deploy start \
              --source-dir .temp/package \
              --target-org deploy-org \
              --test-level RunLocalTests \
              --wait 10
          fi
          
          # V√©rifie le rapport de d√©ploiement
          echo "üìä Rapport de d√©ploiement:"
          sf project deploy report \
            --target-org deploy-org

      # √âtape 9 : G√©n√®re un rapport de couverture de code (s'ex√©cute toujours)
      - name: Generate Test Coverage Report
        if: always() && steps.delta.outputs.has_changes == 'true'
        run: |
          # R√©cup√®re le rapport de test, m√™me si les tests ont √©chou√©
          sf apex get test \
            --code-coverage \
            --result-format human \
            --target-org deploy-org || true
